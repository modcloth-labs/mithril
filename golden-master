#!/usr/bin/env ruby

require 'fileutils'
require 'minitest/spec'
require 'net/http'
require 'uri'

class ServerRunner
  attr_reader :server_binary, :addr, :port, :extra_args
  attr_reader :startup_sleep, :start_time, :server_pid

  def initialize(options = {})
    @start_time = options[:start] || Time.now.utc
    @server_binary = "#{ENV['GOPATH'].split(/:/).first}/bin/mithril-server"
    @addr = options[:port] ? ":#{options[:port]}" : ENV['ADDR']
    @port = (options[:port] || ENV['ADDR'] || '9494').to_s.gsub(/:/, '').to_i
    @extra_args = options[:extra_args] || ''
    @startup_sleep = Float(
      options[:startup_sleep] || ENV['MITHRIL_STARTUP_SLEEP'] || 0.5
    )

    if !File.exist?(server_binary)
      raise "Can't locate `mithril-server` binary! " <<
            "(it's not here: #{server_binary.inspect})"
    end
  end

  def start
    announce! "Starting mithril server with address #{addr}"
    start = start_time.strftime('%Y%m%d%H%M%S')
    @server_pid = Process.spawn(
      "#{server_binary} -a #{addr} #{extra_args}" <<
        ">> ./log/mithril-server-#{start}-#{port}.log 2>&1"
    )
    sleep @startup_sleep
    @server_pid
  end

  def stop
    if server_pid
      announce! "Stopping mithril server with address #{addr} " <<
                "(PID=#{server_pid})"
      Process.kill(:KILL, server_pid)
    end
  end
end

GOLD = "\033\[33;1m"
RESET = "\033\[0m"
GREEN = "\033\[32m"
RED = "\033\[31m"
BRIGHT_GREEN = "\033\[32;1m"
BRIGHT_RED = "\033\[31;1m"

def announce!(something)
  $stderr.puts "#{GOLD}golden#{RESET}: #{GREEN}#{something}#{RESET}"
end

class MiniTestReporter
  def puts(*args)
    args.each { |arg| announce! arg }
  end

  alias print puts
end

def run_psql(command, options = {})
  if options[:user]
    command = "-U #{options[:user]} #{command}"
  end
  output = `psql #{command}`.chomp
  return [output, $?]
end

def post_requests(options = {})
  path = "/#{options[:exchange] || 'foop'}/#{options[:routing_key] || 'fwap'}"
  port = options[:port] || 8371
  request = Net::HTTP::Post.new(path)
  request.content_type = case options[:type]
                         when :json
                           'application/json'
                         when :xml
                           'application/xml'
                         else
                           'application/octet-stream'
                         end

  Integer(options[:count] || 1).times do |n|
    response = Net::HTTP.start('localhost', port) do |http|
      request.body = case options[:type]
                     when :json
                       %Q/{"flume":"sandbag #{rand}"}/
                     when :xml
                       %Q(<flume sandbag="#{rand}"></flume>)
                     else
                       %Q(\x99f\x81l\x78u\x93m\x33e\x90)
                     end
      http.request(request)
    end

    if response.code != '204'
      raise "Failed POST: #{response.inspect}"
    end

    announce! "POSTed #{request.body.inspect} to #{request.path.inspect}"
  end
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SUITE_LOAD_START = Time.now.utc.strftime('%Y%m%d%H%M%S')
PSQL_USER = ENV['TRAVIS'] ? 'postgres' : ENV['USER']
PG_URI = if ENV['TRAVIS']
           'postgres://postgres@localhost?sslmode=disable'
         elsif ENV['MITHRIL_PG_URI']
           ENV['MITHRIL_PG_URI']
         else
           'postgres://localhost?sslmode=disable'
         end
$servers = {
  amqp_only: ServerRunner.new(
    port: rand(9400..9449),
    start: Time.now.utc,
  ),
  with_pg: ServerRunner.new(
    port: rand(9450..9499),
    start: Time.now.utc,
    extra_args: "-pg -pg.uri='#{PG_URI}'"
  )
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

$servers.each do |server_type,server|
  server_name = server_type.to_s.gsub(/_/, ' ')
  describe "#{server_name} mithril server" do
    it 'listens on the specified port' do
      Net::HTTP.get('localhost', '/foop/fwap', server.port).wont_be_empty
    end

    it 'rejects non-pprof GET requests' do
      res = Net::HTTP.get_response('localhost', '/jazz/pant', server.port)
      res.code.must_equal '405'
    end

    it 'serves a favicon' do
      res = Net::HTTP.get_response('localhost', '/favicon.ico', server.port)
      res['Content-Type'].must_equal 'image/vnd.microsoft.icon'
    end
  end
end

describe 'with pg mithril server' do
  # Having tests for the database may seem odd in a golden master/black box
  # style test.  The reasoning here is that by ensuring the database interface,
  # we allow for innovation in "replay clients" (plus mithril doesn't yet have
  # its own).
  it 'ensures the `mithril_requests` table is available' do
    out = run_psql(
      '-t -c "SELECT COUNT(*) FROM mithril_requests"', user: PSQL_USER
    ).first
    count = Integer(out.strip)
    count.must_be :>=, 5
  end

  it 'tracks migrations with a schema migrations table' do
    out = run_psql(
      '-t -c "SELECT * FROM mithril_schema_migrations"',
      user: PSQL_USER
    ).first
    out.split($/).first.strip.wont_be_empty
  end

  describe 'after requests have been POSTed' do
    before do
      run_psql(
        %Q{-t -c "DELETE FROM mithril_requests
                WHERE exchange = 'pg_exchange_#{SUITE_LOAD_START}'"},
                user: PSQL_USER
      )
      post_requests(
        port: $servers[:with_pg].port,
        type: :json,
        count: 5,
        exchange: "pg_exchange_#{SUITE_LOAD_START}",
        routing_key: 'pg.new',
      )
    end

    it 'ensures requests can be selected by `exchange`' do
      out = run_psql(
        %Q{-t -c "SELECT COUNT(*)
                FROM mithril_requests
                WHERE exchange = 'pg_exchange_#{SUITE_LOAD_START}'"},
                user: PSQL_USER
      ).first
      count = Integer(out.strip)
      count.must_equal 5
    end
  end
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def main(argv = [].freeze)
  at_exit do
    $servers.each do |_,runner|
      runner.stop
    end
  end

  Dir.chdir(File.expand_path('../', __FILE__)) do
    FileUtils.mkdir_p('./log')
    $servers.each do |_,runner|
      runner.start
    end
  end

  MiniTest::Unit.output = MiniTestReporter.new
  exit_code = MiniTest::Unit.new.run(argv)

  if exit_code == 0
    $stderr.puts <<-EOF.gsub(/^ {6}/, '')
      #{BRIGHT_GREEN}
      ____ ____ ___ _ ____ ____ ____ ____ ___ _ ____ _  _
      [__  |__|  |  | [__  |___ |__| |     |  | |  | |\\ |
      ___] |  |  |  | ___] |    |  | |___  |  | |__| | \\|

      #{RESET}
    EOF
  else
    $stderr.puts <<-EOF.gsub(/^ {6}/, '')
      #{BRIGHT_RED}
      ___  _ ____ ____ ___  ___  ____ _ _  _ ___ _  _ ____ _  _ ___
      |  \\ | [__  |__| |__] |__] |  | | |\\ |  |  |\\/| |___ |\\ |  |
      |__/ | ___] |  | |    |    |__| | | \\|  |  |  | |___ | \\|  |

      #{RESET}
    EOF
  end

  exit exit_code
end

if __FILE__ == $0
  exit main(ARGV)
end

# vim:filetype=ruby
